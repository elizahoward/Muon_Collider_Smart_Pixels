---
catapult_solution:
  option:
    csim: 1
    SCVerify: 1
    Synth: 1
    vhdl: 1
    verilog: 1
    RTLSynth: 0
    RandomTBFrames: 2
    PowerEst: 0
    PowerOpt: 0
    BuildBUP:        1
    BUPWorkers: 0
    LaunchDA: 0
    startup: {}
    bup_go_state:   extract
    workers:        $CCS_WORKERS
    remote_command: $CCS_REMOTE_COMMAND
  global:
    script: |
      proc report_time { op_name time_start time_end } {
        set time_taken [expr $time_end - $time_start]
        set time_s [expr ($time_taken / 1000) % 60]
        set time_m [expr ($time_taken / (1000*60)) % 60]
        set time_h [expr ($time_taken / (1000*60*60)) % 24]
        puts "***** ${op_name} COMPLETED IN ${time_h}h${time_m}m${time_s}s *****"
      }
      proc setup_xilinx_part { part } {
        # Map Xilinx PART into Catapult library names
        set libname [lindex [library get /CONFIG/PARAMETERS/Vivado/PARAMETERS/Xilinx/PARAMETERS/*/PARAMETERS/*/PARAMETERS/$part/LIBRARIES/*/NAME -match glob -ret v] 0]
        if { [llength $libname] == 1 } {
          set libpath [library get /CONFIG/PARAMETERS/Vivado/PARAMETERS/Xilinx/PARAMETERS/*/PARAMETERS/*/PARAMETERS/$part/LIBRARIES/*/NAME -match glob -ret p]
          if { [regexp {/CONFIG/PARAMETERS/(\S+)/PARAMETERS/(\S+)/PARAMETERS/(\S+)/PARAMETERS/(\S+)/PARAMETERS/(\S+)/.*} $libpath dummy rtltool vendor family speed part] } {
            solution library add $libname -- -rtlsyntool $rtltool -vendor $vendor -family $family -speed $speed
          } else {
            solution library add $libname -- -rtlsyntool Vivado
          }
        } else {
          logfile message "Could not find specific Xilinx base library for part '$part'. Using KINTEX-u\n" warning
          solution library add mgc_Xilinx-KINTEX-u-2_beh -- -rtlsyntool Vivado -manufacturer Xilinx -family KINTEX-u -speed -2 -part xcku115-flvb2104-2-i
        }
        solution library add Xilinx_RAMS
        solution library add Xilinx_ROMS
        solution library add Xilinx_FIFO
        # Point to AMD/Xilinx/Vivado precompiled library cache  
        if { [info exists env(XILINX_PCL_CACHE)] } {
          options set /Flows/Vivado/PCL_CACHE $env(XILINX_PCL_CACHE)
          solution options set /Flows/Vivado/PCL_CACHE $env(XILINX_PCL_CACHE)
        }
      }
      proc setup_asic_libs { args } {
        global env
        set do_saed 0
        foreach lib $args {
          solution library add $lib -- -rtlsyntool DesignCompiler
          if { [lsearch -exact {saed32hvt_tt0p78v125c_beh saed32lvt_tt0p78v125c_beh saed32rvt_tt0p78v125c_beh} $lib] != -1 } {
            set do_saed 1
            # Special case for SAED32 and ADVDPOPT (taken from setup_saed.tcl)
            if { [info exists env(SAED32_EDK)] } {
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib SG] -append
              # Technology Process for layout
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) tech] -append
              # Design Compiler Library (DBs for cells and wire loads)
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib SG db] -append
              ## Prevents $MGC_HOME/pkgs/siflibs/saed from appearing in the cache header for OnTheFly
              #options set ComponentLibs/TechLibSearchPath [file join $::env(MGC_HOME) pkgs siflibs saed ] -append
              options set Flows/DesignCompiler/EnableWireloadSettings true
              #options set Flows/DesignCompiler/libs_db [solution get /TECHLIBS/$lib/VARS/libs_db/VALUE]
              # MilkyWay Libraries (cell, tech, TLU, and map files)
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) tech milkyway] -append
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib stdcell_rvt milkyway] -append
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib stdcell_hvt milkyway] -append
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib stdcell_lvt milkyway] -append
              # Liberty and LEF Libraries
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib SG] -append
              #options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib stdcell_${vth} lef] -append
              # TLU files
              options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) tech star_rcxt] -append
              #options set ComponentLibs/TechLibSearchPath [file join $::env(SAED32_EDK) lib SG] -append
            }
          }
        }
        solution library add ccs_sample_mem
        solution library add ccs_sample_rom
        solution library add hls4ml_lib
        # special exception for SAED32 for use in power estimation
        if { $do_saed } {
          go libraries
          # SAED32 selected - enable DC settings to access Liberty data for power estimation
          source [application get /SYSTEM/ENV_MGC_HOME]/pkgs/siflibs/saed/setup_saedlib.tcl
        }
      }
  go-new:
    script: |
      puts "***** INVOKE OPTIONS *****"
      foreach x [lsort [array names opt]] {
        puts "[format {   %-20s %s} $x $opt($x)]"
      }
      puts ""
      set sfd [file normalize [file dirname [info script]]]
      puts "Setting up solution ..."
      options set Input/CppStandard {c++17}
      options set Input/CompilerFlags -DRANDOM_FRAMES=$opt(RandomTBFrames)
      options set Input/SearchPath {$MGC_HOME/shared/include/nnet_utils} -append
      options set ComponentLibs/SearchPath {$MGC_HOME/shared/pkgs/ccs_hls4ml} -append
      #--------------------------------------------------------
      # Configure Catapult Options
      # downgrade HIER-10
      options set Message/ErrorOverride HIER-10 -remove
      solution options set Message/ErrorOverride HIER-10 -remove
      if {$opt(vhdl)}    {
        options set Output/OutputVHDL true
      } else {
        options set Output/OutputVHDL false
      }
      if {$opt(verilog)} {
        options set Output/OutputVerilog true
      } else {
        options set Output/OutputVerilog false
      }
      #--------------------------------------------------------
      # Configure Catapult Flows
      if { [info exists ::env(XILINX_PCL_CACHE)] } {
        options set /Flows/Vivado/PCL_CACHE $::env(XILINX_PCL_CACHE)
        solution options set /Flows/Vivado/PCL_CACHE $::env(XILINX_PCL_CACHE)
      }
      #--------------------------------------------------------
      # Source optional end-user startup script
      if { [info exists opt(startup)] && ($opt(startup) != "") && [file exists $opt(startup)] } {
        logfile message "Sourcing Catapult AI NN startup script '$opt(startup)'\n" info
        catch {dofile $opt(startup)}
      }
      # Turn on SCVerify flow
      flow package require /SCVerify
      #  flow package option set /SCVerify/INVOKE_ARGS {$sfd/firmware/weights $sfd/tb_data/tb_input_features.dat $sfd/tb_data/tb_output_predictions.dat}
      flow package option set /SCVerify/INVOKE_ARGS "$sfd/firmware/weights"
      # Turn on VSCode flow
      # flow package require /VSCode
      # To launch VSCode on the C++ HLS design:
      #   cd my-Catapult-test
      #   code Catapult.code-workspace
      #--------------------------------------------------------
      #    Start of HLS script
      set design_top myproject
      solution file add [file join $sfd firmware/myproject.cpp]
      solution file add [file join $sfd myproject_test.cpp] -exclude true
      # Parse parameters.h to determine config info to control directives/pragmas
      set IOType io_stream
      if { ![file exists [set parameters_file [file join $sfd firmware/parameters.h]]] } {
        logfile message "Could not locate firmware/parameters.h. Unable to determine network configuration.\n" warning
      } else {
        set pf [open $parameters_file "r"]
        set line {}
        while {![eof $pf]} {
          gets $pf line
          if { [string match {*io_type = nnet::io_stream*} $line] } {
            set IOType io_stream
            break
          }
        }
        close $pf
        unset line pf
      }
      if { $IOType == "io_stream" } {
        solution options set Architectural/DefaultRegisterThreshold 2050
      }
      #hls-fpga-machine-learning insert directives analyze
      directive set RESET_CLEARS_ALL_REGS no
      directive set MEM_MAP_THRESHOLD [expr 2048 * 16 + 1]
      directive set REDUNDANT_RTL_ELIMINATION false
      #directive set -RESET_CLEARS_ALL_REGS no
      # Constrain arrays to map to memory only over a certain size
      #directive set -MEM_MAP_THRESHOLD [expr 2048 * 16 + 1]
      # The following line gets modified by the backend writer
      set hls_clock_period 5
      # Apply the CLOCKs directive
      directive set -CLOCKS [list clk [list -CLOCK_PERIOD $hls_clock_period -CLOCK_EDGE rising -CLOCK_OFFSET 0.000000 -CLOCK_UNCERTAINTY 0.0 -RESET_KIND sync -RESET_SYNC_NAME rst -RESET_SYNC_ACTIVE high -RESET_ASYNC_NAME arst_n -RESET_ASYNC_ACTIVE low -ENABLE_NAME {} -ENABLE_ACTIVE high]]
      # Run default flow in shell mode
      if {! [gui exists]} {
        go compile
        if { $opt(Synth) } {
          go extract
          if {$opt(PowerEst)} {
            go switching
          }
          if {$opt(PowerOpt)} {
            go power
          }
        }
      }
  go-pre-analyze:
    type: top
    script: |
      solution add /DATUM/FIELDS/build_bottomup/VALUE $opt(BuildBUP)
      solution add /DATUM/FIELDS/build_bottomup_go_state/VALUE $opt(bup_go_state)
      solution add /DATUM/FIELDS/build_workers/VALUE $opt(workers)
      solution add /DATUM/FIELDS/build_remote_command/VALUE $opt(remote_command)
  go-analyze:
    type: top
    script: |
      if {$opt(LaunchDA) && [gui exists]} {
        puts "***** Launching DA *****"
        flow run /DesignAnalyzer/launch
      }
      #hls-fpga-machine-learning insert directives compile
  go-compile:
    type: top
    script: |
      if {$opt(csim)} {
        puts "***** C SIMULATION *****"
        set time_start [clock clicks -milliseconds]
        flow run /SCVerify/launch_make ./scverify/Verify_orig_cxx_osci.mk {} SIMTOOL=osci sim
        set time_end [clock clicks -milliseconds]
        report_time "C SIMULATION" $time_start $time_end
      }
      setup_xilinx_part {xcvu13p-flga2577-2-e}
      #hls-fpga-machine-learning insert directives assembly
      directive set ADVANCED_DPOPT false
  go-assembly:
    type: top
    script: |
      set design [solution get -name]
      logfile message "Adjusting FIFO_DEPTH for top-level interconnect channels\n" warning
      # FIFO interconnect between layers
      foreach ch_fifo_m2m [directive get -match glob -checkpath 0 -ret p $design/*_out:cns/MAP_TO_MODULE] {
        set ch_fifo [join [lrange [split $ch_fifo_m2m '/'] 0 end-1] /]/FIFO_DEPTH
        logfile message "directive set -match glob $ch_fifo 1\n" info
        directive set -match glob "$ch_fifo" 1
      }
      # For bypass paths - the depth will likely need to be larger than 1
      foreach ch_fifo_m2m [directive get -match glob -checkpath 0 -ret p $design/*_cpy*:cns/MAP_TO_MODULE] {
        set ch_fifo [join [lrange [split $ch_fifo_m2m '/'] 0 end-1] /]/FIFO_DEPTH
        logfile message "Bypass FIFO '$ch_fifo' depth set to 1 - larger value may be required to prevent deadlock\n" warning
        logfile message "directive set -match glob $ch_fifo 1\n" info
        directive set -match glob "$ch_fifo" 1
      }
  go-extract:
    type: top
    script: |
      project save
      if {$opt(SCVerify) } {
        if { $opt(vhdl) } {
          flow run /SCVerify/launch_make ./scverify/Verify_rtl_vhdl_msim.mk {} SIMTOOL=msim sim
        }
        if { $opt(verilog) } {
          flow run /SCVerify/launch_make ./scverify/Verify_rtl_v_msim.mk {} SIMTOOL=msim sim
        }
      }
      if {!$opt(PowerOpt) && $opt(RTLSynth)} {
        # find last RTL synthesis script created (either extract or power stage)
        set launch {}
        foreach {p v} [solution get /OUTPUTFILES/.../FILETYPE -match glob -rec 1 -ret pv] {
          if { $v == "SYNTHESIS" } {
            set p1 [file dirname $p]
            set nettype [string tolower [solution get $p1/DEPENDENCIES/1/FILETYPE -checkpath 0]]
            if { [info exists opt($nettype)] && $opt($nettype) } {
              set launch [lindex [lindex [solution get $p1/FLOWS] 0] 1]
            }
          }
        }
        if { $launch != {} } {
          puts "***** RTL SYNTHESIS *****"
          set time_start [clock clicks -milliseconds]
          eval flow run $launch
          set time_end [clock clicks -milliseconds]
          report_time "RTL SYNTHESIS" $time_start $time_end
        } else {
          logfile message "RTL Synthesis flow lookup failed\n" warning
        }
      }
      if { [catch {flow package present /HLS4ML}] == 0 } {
        flow run /HLS4ML/collect_reports
      }
  go-pre-switching:
    type: top
    script: |
      if {$opt(PowerEst)} {
        puts "***** Pre Power Optimization *****"
      }
  go-switching:
    type: top
    script: |
      if {$opt(PowerEst)} {
        if {$opt(verilog)}    {
          flow run /PowerAnalysis/report_pre_pwropt_Verilog
        }
        if {$opt(vhdl)}    {
          flow run /PowerAnalysis/report_pre_pwropt_VHDL
        }
      }
  go-pre-power:
    type: top
    script: |
      if {$opt(PowerOpt)} {
        puts "***** Power Optimization *****"
      }
...
